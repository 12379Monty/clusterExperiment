% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seqCluster.R
\name{seqCluster}
\alias{seqCluster}
\title{Program for sequentially clustering, removing cluster, and starting again.}
\usage{
seqCluster(x = NULL, diss = NULL, k0, subsample = TRUE, beta = 0.7,
  top.can = 15, remain.n = 30, k.min = 3, k.max = k0 + 10,
  verbose = TRUE, subsampleArgs = NULL, clusterDArgs = NULL,
  checkDiss = TRUE)
}
\arguments{
\item{x}{\code{p x n} data matrix on which to run the clustering (samples in
columns).}

\item{diss}{\code{n x n} data matrix of dissimilarities between the samples
on which to run the clustering}

\item{k0}{the value of K at the first iteration of sequential algorithm, see
details below or vignette.}

\item{subsample}{logical as to whether to subsample via 
\code{\link{subsampleClustering}} to get the distance matrix at each 
iteration; otherwise the distance matrix is set by arguments to
\code{\link{clusterD}}.}

\item{beta}{value between 0 and 1 to decide how stable clustership membership
has to be before 'finding' and removing the cluster.}

\item{top.can}{only the top.can clusters from \code{\link{clusterD}} (ranked
by 'orderBy' argument given to \code{\link{clusterD}}) will be compared
pairwise for stability. Making this very big will effectively remove this
parameter and all pairwise comparisons of all clusters found will be
considered. This might result in smaller clusters being found. Current
default is fairly large, so probably will have little effect.}

\item{remain.n}{when only this number of samples are left (i.e. not yet
clustered) then algorithm will stop.}

\item{k.min}{each iteration of sequential detection of clustering will
decrease the beginning K of subsampling, but not lower than k.min.}

\item{k.max}{algorithm will stop if K in iteration is increased beyond this
point.}

\item{verbose}{whether the algorithm should print out information as to its
progress.}

\item{subsampleArgs}{list of arguments to be passed to
\code{\link{subsampleClustering}}.}

\item{clusterDArgs}{list of arguments to be passed to
\code{\link{clusterD}}(which can include arguments to be passed to
\code{\link{cluster01}} or \code{\link{clusterK}}).}
}
\value{
A list with values
\itemize{

\item{\code{clustering}}{ a vector of length equal to nrows(x) giving the
integer-valued cluster ids for each sample. The integer values are assigned
in the order that the clusters were found. "-1" indicates the sample was not
clustered.}

\item{\code{clusterInfo}}{ if clusters were successfully found, a matrix of
information regarding the algorithm behavior for each cluster (the starting
and stopping K for each cluster, and the number of iterations for each
cluster).}

\item{\code{whyStop}}{ a character string explaining what triggered the
algorithm to stop.}
}
}
\description{
Given a data matrix, this function will call clustering
routines, and sequentially remove best clusters, and iterate to find
clusters.
}
\details{
This code is adapted from the code of the tightClust
 package of Tseng and Wong. At each iteration of the algorithm it finds a set of samples that constitute a homogeneous cluster and remove them, and iterate again to find the next set of samples that form a cluster.

In each iteration, to determine the next set of homogeneous set of samples, the algorithm will iteratively cluster the current set of samples for a series of increasing values of the parameter $K$, starting at a value \code{kinit} and increasing by 1 at each iteration, until a sufficiently homogeneous set of clusters is found. For the first set of homogeneous samples, \code{kinit} is set to the argument $k0$, and for iteration, \code{kinit} is increased internally.

Depending on the value of \code{subsample} how the value of $K$ is used differs. If \code{subsample=TRUE}, $K$ is the \code{k} sent to the cluster function \code{\clusterFunction} sent to  \code{\link{subsamplingCluster}} via \code{subsampleArgs}; then \code{\link{clusterD}} is run on the result of the co-occurance matrix from \code{\link{subsamplingCluster}} with the \code{ClusterFunction} object defined in the argument \code{clusterFunction} set via \code{clusterDArgs}. The number of clusters actually resulting from this run of \code{\link{clusterD}} may not be equal to the $K$ sent to  the clustering done in \code{\link{subsamplingCluster}}. If \code{subsample=FALSE}, \code{\link{clusterD}} is called directly on the data to determine the clusters and $K$ set by \code{seqCluster} for this iteration determines the parameter of the clustering done by \code{\link{clusterD}}. Specifically, the argument \code{clusterFunction} defines the clustering of the \code{\link{clusterD}} step and \code{k} is sent to that \code{ClusterFunction} object. This means that if \code{subsample=FALSE}, the \code{clusterFunction} must be of \code{algorithmType} "K". 
  @details In either setting of \code{subsample}, the resulting clusters from \code{\link{clusterD}} for a particular $K$ will be compared to
  clusters found in the previous iteration of $K-1$. For computational (and other?) convenience, only the
  first \code{top.can} clusters of each iteration will be compared to the first
  \code{top.can} clusters of previous iteration for similarity (where \code{top.can}
  currently refers to ordering by size, so first \code{top.can} largest clusters.

If there is no cluster of the first \code{top.can} in the current iteration $K$
  that has overlap similarity > \code{beta} to any in the previous iteration, then
  the algorithm will move to the next iteration, increasing to $K+1$.

If, however, of these clusters there is a cluster in the current iteration $K$ that has overlap
  similarity > beta to a cluster in the previous iteration $K-1$, then the cluster
  with the largest such similarity will be identified as a homogenous set of samples
  and the samples in it will be removed and designated as such. The algorithm
  will then start again to determine the next set of homogenous samples, but without these samples.
  Furthermore, in this case (i.e. a cluster was found and removed), the value of \code{kinit} will be be reset to \code{kinit-1}; i.e. the range of increasing $K$ that will be iterated over to find a set of homogenous samples will start off one value less than was the case for the previous set of homogeneous samples. If \code{kinit-1}<\code{k.min}, then \code{kinit} will be set
  to \code{k.min}.

If there are less than \code{remain.n} samples left after finding a cluster
  and removing its samples, the algorithm will stop, as subsampling is deamed
  to no longer be appropriate. If the K has to be increased to beyond \code{k.max}
  without finding any pair of clusters with overlap > beta, then the
  algorithm will stop. Any samples not found as part of a homogenous set of clusters at that point will be classified as unclustered (given a value
  of -1)

Required format for clustering functions: The choice of 'subsample' also controls what type of clustering functions can be used in subsampling and in the clusterD steps. If \code{subsample=TRUE} the \code{ClusterFunction} object given to \code{subsamplingArgs} must be of type 'K' (and if missing uses the default for \code{\link{subsamplingClustering}}, currently "pam"); the resulting co-clustering matrix is given to \code{diss} (specificaly 1-coclustering values) of \code{\link{clusterD}} and so the \code{ClusterFunction} object given to \code{\link{clusterD}} via the argument \code{clusterFunction} of \code{seqCluster} must take input of the form of a dissimilarity. If subsample=FALSE, then \code{\link{clusterD}} is run on the input (either \code{x} or \code{diss}) and the \code{clusterFunction} must define a \code{ClusterFunction} object with \code{algorithmType} 'K'.

If clusterFunction is of type 'K' (e.g. "pam", see
  \code{\link{clusterD}}) the 'k' argument of \code{\link{clusterK}} called
  by \code{\link{clusterD}} is set to the current iteration of K by the
  sequential iteration, so setting 'k=' in the list given to clusterDArgs
  will not do anything and will produce a warning to that effect.

Similarly, the current K of the iteration also determines the 'k'
  argument passed to \code{\link{subsampleClustering}}  so setting 'k=' in
  the list given to the subsampleArgs will not do anything and will produce a
  warning to that effect.

If subsample=FALSE and 'findBestK=FALSE' is passed to clusterDArgs,
  then each iteration will run the clustering given by clusterFunction on
  dist(x) iterating over k. However, if subsample=FALSE, you should not set
  'findBestK=TRUE' (otherwise clustering dist(x) will be essentially the same
  for iterating over different k and there is no method implemented to change
  the choice of how to remove a cluster other than similarity as you change
  k); an error message will be given if this combination of options are set.

However, if clusterFunction="pam" (or is of type 'K') and
  subsample=TRUE passing either 'findBestK=TRUE' or 'findBestK=FALSE' will
  function as expected. In particular, the iteration over K will set the
  number of clusters for clustering of each subsample. If findBestK=FALSE,
  that same K will be used for clustering of DMat. If findBestK=TRUE, then
  \code{\link{clusterD}} will search for best k; note that the default
  'kRange' over which \code{\link{clusterD}} searches when findBestK=TRUE
  depends on the input value of 'k' (you can change this to a fixed set of
  values by setting 'kRange' explicitly in the clusterDArgs list).
}
\examples{
\dontrun{
data(simData)

set.seed(12908)
clustSeqHier <- seqCluster(simData, k0=5, subsample=TRUE,
beta=0.8, subsampleArgs=list(resamp.n=100,
samp.p=0.7, clusterFunction="kmeans", clusterArgs=list(nstart=10)),
clusterDArgs=list(minSize=5,clusterFunction="hierarchical01",clusterArgs=list(alpha=0.1)))
}
}
\references{
Tseng and Wong (2005), "Tight Clustering: A Resampling-Based
  Approach for Identifying Stable and Tight Patterns in Data", Biometrics,
  61:10-16.
}
\seealso{
tight.clust
}
