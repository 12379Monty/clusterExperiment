% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/plotCoClustering.R, R/plotHeatmap.R
\docType{methods}
\name{plotCoClustering}
\alias{plotCoClustering}
\alias{plotCoClustering,ClusterExperiment-method}
\alias{plotHeatmap}
\alias{plotHeatmap,ClusterExperiment-method}
\alias{plotHeatmap,matrix-method}
\title{Heatmap for showing clustering results and more}
\usage{
plotCoClustering(data, ...)

plotHeatmap(data, ...)

\S4method{plotCoClustering}{ClusterExperiment}(data, ...)

\S4method{plotHeatmap}{SummarizedExperiment}(data, isCount = FALSE,
  transFun = NULL, ...)

\S4method{plotHeatmap}{ClusterExperiment}(data, visualize = c("original",
  "transformed", "centeredAndScaled"), orderSamples = c("dendrogramValue",
  "hclust", "orderSamplesValue", "primaryCluster"),
  whichFeatures = c("mostVar", "all", "PCA"), nFeatures = NULL,
  whichClusters = c("primary", "pipeline", "all", "none"),
  sampleData = NULL, clusterFeatures = TRUE, colorScale = if
  (centerAndScaleFeatures) seqPal3 else seqPal5, ...)

\S4method{plotHeatmap}{matrix}(data, sampleData = NULL,
  clusterSamplesData = data, clusterFeaturesData = data,
  whSampleDataCont = NULL, clusterSamples = TRUE, showSampleNames = FALSE,
  clusterFeatures = TRUE, showFeatureNames = FALSE, colorScale = seqPal5,
  clusterLegend = NULL, alignSampleData = FALSE,
  unassignedColor = "white", missingColor = "grey", breaks = NA,
  isSymmetric = FALSE, ...)
}
\arguments{
\item{data}{data to use to determine the heatmap}

\item{...}{passed to aheatmap}

\item{isCount}{logical. Whether the data are in counts, in which case the
default \code{transFun} argument is set as log(x+1). This is simply a
convenience to the user, and can be overridden by giving an explicit function
to \code{transFun}.}

\item{transFun}{function A function to use to transform the input data matrix
before clustering.}

\item{visualize}{character, indicating what form of the data should be used for visualizing the data (i.e. for making the color-scale)}

\item{orderSamples}{character or integers. Indicates how the samples should be clustered (or gives indices of the order for the samples). See details.}

\item{sampleData}{If input is either a ClusterExperiment or SummarizedExperiment object, then \code{sampleData} must index the sampleData stored as a DataFrame in \code{colData} slot of the object. Whether the data is continuous or not will be determined by the properties of \code{colData}}

\item{clusterFeatures}{Logical as to whether to do hiearchical clustering of
features (if FALSE, any input to clusterFeaturesData is ignored)}

\item{colorScale}{palette of colors for the color scale of heatmap}

\item{clusterSamplesData}{Either a matrix that will be used to in hclust to define the hiearchical clustering of
samples (e.g. normalized data) or a pre-existing dendrogram that clusters the samples}

\item{clusterFeaturesData}{Either a matrix that will be used to in hclust to define the hiearchical clustering of
features (e.g. normalized data) or a pre-existing dendrogram that clusters the features}

\item{whSampleDataCont}{Which of the sampleData columns are continuous and should not be converted to counts. NULL indicates no additional sampleData.}

\item{clusterSamples}{Logical as to whether to do hierarchical clustering of
cells (if FALSE, any input to clusterSamplesData is ignored)}

\item{showSampleNames}{Logical as to whether show cell names}

\item{showFeatureNames}{Logical as to whether show cell names}

\item{clusterLegend}{Assignment of colors to the clusters. If NULL, sampleData columns
will be assigned colors internally. clusterLegend should be list of length equal to
ncol(sampleData) with names equal to the colnames of sampleData. Each element of the
list should be a either the format requested by aheatmap (a vector of colors with names corresponding to the levels of
the column of sampleData), or should be format of ClusterExperiment.}

\item{alignSampleData}{Logical as to whether should align the colors of the sampleData (only if clusterLegend not given and sampleData is not NULL)}

\item{unassignedColor}{color assigned to cluster values of '-1' ("unassigned")}

\item{missingColor}{color assigned to cluster values of '-2' ("missing")}

\item{breaks}{Either a vector of breaks (should be equal to length 52), or a
number between 0 and 1, indicating that the breaks should be equally spaced
(based on the range in the data) upto the `breaks' quantile, see \code{\link{setBreaks}}}

\item{sampleData}{If input is matrix, \code{sampleData} is a matrix of additional data on the samples to show above heatmap. Unless indicated by \code{whSampleDataCont}, \code{sampleData} will be converted into factors, even if numeric.  ``-1'' indicates the sample was not assigned to a cluster and
gets color `unassignedColor' and '-2' gets the color 'missingColor'}
}
\value{
If \code{data} is a matrix, returns (invisibly) a list with elements
\itemize{
\item{\code{breaks}}{The breaks used for aheatmap, after adjusting for quantile}
\item{\code{annCol}}{the annotation data.frame given to aheatmap}
\item{\code{clusterLegend}}{the annotation colors given to aheatmap}
}
aheatmapOut=out,sampleData=annCol,clusterLegend=clusterLegend,breaks=breaks))
}
\description{
Make heatmap with color scale from one matrix and hiearchical clustering
of samples/features from another. Also built in functionality for showing the
clusterings with the heatmap. Builds on \code{\link{aheatmap}} function of \code{NMF} package
}
\details{
The plotHeatmap function calles \code{\link{aheatmap}} to draw the heatmap. The main point of \code{plotHeatmap} is to 1) allow for different matrix inputs, separating out the color scale visualization and the clustering of the samples/features. 2) to visualize the clusters and meta data with the heatmap. The intended purpose is to allow the user to visualize the original count scale of the data (on the log-scale), but create the hierarchical clustering on another, more appropriate dataset for clustering, such as normalized data. Similarly, some of the palettes were developed assuming that the visualization might be on unscaled/uncentered data, rather than the residual from the mean of the gene, and thus palettes need to take on a greater range of relevant values so as to show meaningful comparisons with genes on very different scales.

If \code{annCol} contains a column of continuous data, whSampleDataCont should give the index of the column(s); otherwise the annotation data for those columns will be forced into a non-sensical factor (with nlevels equal the the number of samples).

Note that plotHeatmap calles aheatmap under the hood. This allows you to
plot multiple heatmaps via par(mfrow=c(2,2)), etc. However, the dendrograms
do not resize if you change the size of your plot window in an interactive
session of R (this might be a problem for RStudio if you want to pop it out
into a large window...).

If \code{breaks} is a numeric value between 0 and 1, then \code{breaks} is assumed to indicate the upper quantile (on the log scale) at which the heatmap color scale should stop. For example, if breaks=0.9, then the breaks will evenly spaced up until the 0.9 upper quantile of the log of the \code{heatData}, and then all values after the 0.9 quantile will be absorbed by the upper-most color bin. This can help to reduce the visual impact of a few highly expressed genes (variables).

If both \code{sampleData} and \code{clusterings} are provided, \code{clusterings} will be shown closest to data (i.e. on bottom) and \code{sampleData} on top. A user that wishes greater control should simply combine the two independently and give the combined matrix in sampleData.

If \code{data} is a \code{ClusterExperiment} object, \code{visualize} indicates what kind of transformation should be done to \code{assay(data)} for calculating the color scale.

If \code{data} is a \code{ClusterExperiment} object,
}
\examples{
data(simData)
cl<-rep(1:3,each=100)
cl2<-cl
changeAssign<-sample(1:length(cl),80)
cl2[changeAssign]<-sample(cl[changeAssign])
ce<-clusterExperiment(simCount,cl2,transformation=function(x){log(x+1)})

#simple, minimal, example. Show counts, but cluster on underlying means
plotHeatmap(ce)

#assign cluster colors
colors<-bigPalette[20:23]
names(colors)<-1:3
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,clusterLegend=list(colors))

#show two different clusters
anno<-data.frame(cluster1=cl,cluster2=cl2)
out<-plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,annCol=anno)
#return the values to see format for giving colors to the annotations
out$clusterLegend

#assign colors to the clusters based on plotClusters algorithm
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,annCol=anno,
alignSampleData=TRUE)

#assign colors manually
annoColors<-list(cluster1=c("black","red","green"),
cluster2=c("blue","purple","yellow"))
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,annCol=anno,
clusterLegend=annoColors)

#give a continuous valued -- need to indicate columns
anno2<-cbind(anno,Cont=c(rnorm(100,0),rnorm(100,2),rnorm(100,3)))
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,annCol=anno2,
whSampleDataCont=3)
#compare changing breaks quantile on visual effect
\dontrun{
par(mfrow=c(2,2))
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,colorScale=seqPal1,
breaks=1,main="Full length")
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,colorScale=seqPal1,
breaks=.99,main="0.99 Quantile Upper Limit")
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,colorScale=seqPal1,
breaks=.95,main="0.95 Quantile Upper Limit")
plotHeatmap(cl,heatData=simCount,clusterSamplesData=simData,colorScale=seqPal1,
breaks=.90,main="0.90 Quantile Upper Limit")
}



}
\author{
Elizabeth Purdom
}

