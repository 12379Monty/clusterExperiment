% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getFeatures.R
\docType{methods}
\name{getBestFeatures,matrix-method}
\alias{getBestFeatures}
\alias{getBestFeatures,ClusterExperiment-method}
\alias{getBestFeatures,matrix-method}
\title{Function for finding best features associated with clusters}
\usage{
\S4method{getBestFeatures}{matrix}(x, cl, type = c("F", "Dendro", "Pairs",
  "OneAgainstAll"), dendro = NULL, pairMat = NULL, returnType = c("Table",
  "Index"), contrastAdj = c("All", "PerContrast", "AfterF"),
  countData = FALSE, ...)

\S4method{getBestFeatures}{ClusterExperiment}(x, type = c("F", "Dendro",
  "Pairs", "OneAgainstAll"), pairMat = NULL, returnType = c("Table",
  "Index"), contrastAdj = c("All", "PerContrast", "AfterF"),
  countData = FALSE, ...)
}
\arguments{
\item{x}{data for the test. Can be a numeric matrix or a
\code{\link{ClusterExperiment}}.}

\item{cl}{A numeric vector with cluster assignments to compare to clRef.
``-1'' indicates the sample was not assigned to a cluster.}

\item{type}{What type of test to do. `F' gives the omnibus F-statistic,
`Dendro' traverses the given dendrogram and does contrasts of the samples
in each side,  `Pairs' does pair-wise contrasts based on the pairs given in
pairMat (if pairMat=NULL, does all pairwise), and `OneAgainstAll' compares
each cluster to the average of all others.}

\item{dendro}{The dendrogram to traverse if type="Dendro". Note that this
should be the dendrogram of the clusters, not of the individual samples.}

\item{pairMat}{matrix giving the pairs of clusters for which to do pair-wise
contrasts (must match to elements of cl). If NULL, will do all pairwise of
the clusters in \code{cl} (excluding "-1" categories). Each row is a pair
to be compared and must match the names of the clusters in the vector
\code{cl}.}

\item{returnType}{Whether to return the index of genes, or the full table
given by topTable or topTableF.}

\item{contrastAdj}{What type of FDR correction to do for contrasts tests
(i.e. if type='Dendro' or 'Pairs').}

\item{countData}{logical as to whether input data is count data, in which
case to perform voom correction to data. See details.}

\item{...}{options to pass to \code{\link{topTable}} or
\code{\link{topTableF}} (see \code{\link{limma}} package)}
}
\value{
A \code{data.frame} in the same format as
  \code{\link[limma]{topTable}}, except for the following additional or
  changed columns:
\itemize{

\item{\code{Feature}}{ This is the column called 'ProbeID' by
\code{\link{topTable}}}

\item{\code{IndexInOriginal}}{ Gives the index of the feature to the original
input dataset, \code{x}}

\item{\code{Contrast}}{ The contrast that the results corresponds to (if
applicable, depends on \code{type} argument)}

\item{\code{ContrastName}}{ The name of the contrast that the results
corresponds to. For dendrogram searches, this will be the node of the tree of
the dendrogram.}
}
}
\description{
Calls limma on input data to determine features most associated
  with found clusters (based on an F-statistic, pairwise comparisons, or
  following a tree that clusters the clusters).
}
\details{
getBestFeatures returns the top ranked features corresponding to a
  cluster assignment. It uses limma to fit the models, and limma's functions
  \code{\link[limma]{topTable}} or \code{\link[limma]{topTableF}} to find the
  best features. See the options of these functions to put better control on
  what gets returned (e.g. only if significant, only if log-fc is above a
  certain amount, etc.). In particular, set `number=` to define how many
  significant features to return (where number is per contrast for the
  `Pairs` or `Dendro` option)

When `type` argument implies that the best features should be found
  via contrasts (i.e. 'type' is `Pairs` or `Dendro`), then then `contrastAdj`
  determines the type of multiple testing correction to perform.
  `PerContrast` does FDR correction for each set of contrasts, and does not
  guarantee control across all the different contrasts (so probably not the
  preferred method). `All` calculates the corrected p-values based on FDR
  correction of all of the contrasts tested. `AfterF` controls the FDR based
  on a hierarchical scheme that only tests the contrasts in those genes where
  the omnibus F statistic is significant. If the user selects `AfterF`, the
  user must also supply an option `p.value` to have any effect, and then only
  those significant at that p.value level will be returned. Note that
  currently the correction for `AfterF` is not guaranteed to control the FDR;
  improvements will be added in the future.

Note that the default option for \code{\link[limma]{topTable}} is
  to not filter based on adjusted p-values (\code{p.value = 1}) and return
  only the top 10 most significant (\code{number = 10}) -- these are options
  the user can change (these arguments are passed via the \code{...} in
  \code{getBestFeatures}). In particular, it only makes sense to set
  \code{requireF = TRUE} if \code{p.value} is meaningful (e.g. 0.1 or 0.05);
  the default value of \code{p.value = 1} will not result in any effect on
  the adjusted p-value otherwise.

\code{countData} triggers whether the "voom" correction will be 
  performed in \code{limma}. If the input data is a matrix is counts (or a 
  `ClusterExperiment` object with counts as the primary data before 
  transformation) this should be set to TRUE and they will be log-transformed
  internally by voom for the differential expression analysis in a way that 
  accounts for the difference in the mean-variance relationships. Otherwise, 
  dat should be on the correct (log) scale for differential expression 
  analysis without a need a variance stabilization (e.g. microarray data). 
  Currently the default is set to FALSE, simply because the countData has not
  been heavily tested. If the But TRUE with \code{x} being counts really 
  should be the default for RNA-Seq data. If the input data is a 
  `ClusterExperiment` object, setting `countData=TRUE` will cause the program
  to ignore the internally stored transformation function and instead use 
  voom with log(x+1). Alternatively, `countData=FALSE` for a 
  `ClusterExperiment` object will cause the DE to be performed with `limma` 
  after transforming the data with the stored transformation. Although some
  writing about "voom" seem to suggest that it would be appropriate for
  arbitrary transformations, the authors have cautioned against using it for
  anything other than count data on mailing lists. For this reason we are not
  implementing it for arbitrary transformations at this time (e.g.
  log(FPKM+epsilon) transformations).
}
\examples{
data(simData)

#create a clustering, for 8 clusters (truth was 4)
cl <- clusterSingle(simData, clusterFunction="pam", subsample=FALSE,
sequential=FALSE, clusterDArgs=list(k=8))

#basic F test, return all, even if not significant:
testF <- getBestFeatures(cl, type="F", number=nrow(simData),
countData=FALSE)

#Do all pairwise, only return significant, try different adjustments:
pairsPerC <- getBestFeatures(cl, type="Pairs", contrastAdj="PerContrast",
p.value=0.05, countData=FALSE)
pairsAfterF <- getBestFeatures(cl, type="Pairs", contrastAdj="AfterF",
p.value=0.05, countData=FALSE)
pairsAll <- getBestFeatures(cl, type="Pairs", contrastAdj="All",
p.value=0.05, countData=FALSE)

#not useful for this silly example, but could look at overlap with Venn
allGenes <- paste("Row", 1:nrow(simData),sep="")
if(require(limma)){
 vennC <- vennCounts(cbind(PerContrast= allGenes \%in\% pairsPerC$Feature,
 AllJoint=allGenes \%in\% pairsAll$Feature, FHier=allGenes \%in\%
 pairsAfterF$Feature))
vennDiagram(vennC, main="FDR Overlap")
}

#Do one cluster against all others
oneAll <- getBestFeatures(cl, type="OneAgainstAll", contrastAdj="All",
p.value=0.05)

#Do dendrogram testing
hcl <- makeDendrogram(cl)
allDendro <- getBestFeatures(hcl, type="Dendro", contrastAdj=c("All"),
number=ncol(simData), p.value=0.05)

# do DE on counts using voom
# compare results to if used simData instead (not on count scale).
# Again, not relevant for this silly example, but basic principle useful
testFVoom <- getBestFeatures(simCount, primaryCluster(cl), type="F",
number=nrow(simData), countData=TRUE)
plot(testF$P.Value[order(testF$Index)],
testFVoom$P.Value[order(testFVoom$Index)],log="xy")

}

