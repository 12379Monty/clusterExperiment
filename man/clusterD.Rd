% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clusterD.R
\docType{methods}
\name{clusterD}
\alias{clusterD}
\alias{clusterD-character-method}
\alias{clusterD,ClusterFunction-method}
\alias{getPostProcessingArgs,ClusterFunction-method}
\alias{getPostProcessingArgs}
\title{Cluster distance matrix from subsampling}
\usage{
\S4method{clusterD}{character}(clusterFunction, ...)

\S4method{clusterD}{ClusterFunction}(clusterFunction, x = NULL, diss = NULL,
  distFunction = NA, clusterArgs = NULL, minSize = 1,
  orderBy = c("size", "best"), format = c("vector", "list"),
  checkArgs = TRUE, checkDiss = TRUE, returnData = FALSE, ...)

\S4method{getPostProcessingArgs}{ClusterFunction}(clusterFunction)
}
\arguments{
\item{clusterFunction}{a \code{\link{ClusterFunction}} object that defines the clustering routine. See \code{\link{ClusterFunction}} for required format of user-defined clustering routines. User can also give a character value to the argument \code{clusterFunction} to indicate the use
of clustering routines provided in package. Type \code{\link{builtInClusterFunctions}} at command prompt to see the built-in clustering routines. If \code{clusterFunction} is missing, the default is set to "pam".}

\item{...}{arguments passed to the post-processing steps of the clustering. The available post-processing arguments for a \code{ClusterFunction} object depend on it's algorithm type and can be found by calling \code{getPostProcessingArgs}. See details below for documentation.}

\item{x}{\code{p x n} data matrix on which to run the clustering (samples in
columns).}

\item{diss}{\code{n x n} data matrix of dissimilarities between the samples
on which to run the clustering}

\item{distFunction}{a distance function to be applied to \code{D}. Only relevant if
input \code{D} is a matrix of data, rather than a distance. See details.}

\item{clusterArgs}{arguments to be passed directly to the \code{clusterFUN} slot of the \code{ClusterFunction} object}

\item{minSize}{the minimum number of samples in a cluster. Clusters found
below this size will be discarded and samples in the cluster will be given
a cluster assignment of "-1" to indicate that they were not clustered.}

\item{orderBy}{how to order the cluster (either by size or by maximum alpha
value). If orderBy="size" the numbering of the clusters are reordered by
the size of the cluster, instead of by the internal ordering of the
\code{clusterFUN} defined in the \code{ClusterFunction} object (an internal ordering is only possible if slot \code{outputType} of the \code{ClusterFunction} is \code{"list"}).}

\item{format}{whether to return a list of indices in a cluster or a vector of
clustering assignments. List is mainly for compatibility with sequential
part.}

\item{checkArgs}{logical as to whether should give warning if arguments given
that don't match clustering choices given. Otherwise, inapplicable
arguments will be ignored without warning.}

\item{returnData}{logical as to whether to return the \code{diss} or \code{x} matrix in the output. If \code{FALSE} only the clustering vector is returned.}
}
\value{
clusterD returns a vector of cluster assignments (if format="vector")
  or a list of indices for each cluster (if format="list"). Clusters less
  than minSize are removed.
}
\description{
Given input data, this function will
  try to find the clusters based on the given ClusterFunction object.
}
\details{
To provide a distance matrix via the argument \code{distFunction},
    the function must be defined to take the distance of the rows of a matrix
    (internally, the function will call \code{distFunction(t(x))}. This is to
    be compatible with the input for the \code{dist} function.
    \code{as.matrix} will be performed on the output of \code{distFunction},
    so if the object returned has a \code{as.matrix} method that will convert
    the output into a symmetric matrix of distances, this is fine (for
    example the class \code{dist} for objects returned by \code{dist} have
    such a method). If \code{distFunction=NA}, then a default distance will 
    be calculated based on the type of clustering algorithm of 
    \code{clusterFunction}. For type "K" the default is to take \code{dist}
    as the distance function. For type "01", the default is to take the
    (1-cor(x))/2.

Post-processing Arguments: For post-processing the clustering, currently only type 'K' algorithms have a defined post-processing. Specifically
\itemize{
 \item{"findBestK"}{logical, whether should find best K based on average
  silhouette width (only used if clusterFunction of type "K").}
 \item{"kRange"}{vector of integers to try for k values if findBestK=TRUE. If \code{k} is given in \code{clusterArgs}, then default is k-2 to k+20, subject to those values being
  greater than 2; if not the default is \code{2:20}. Note that default values depend on the input k, so running
  for different choices of k and findBestK=TRUE can give different answers
  unless kRange is set to be the same.}
 \item{"removeSil"}{logical as to whether remove the assignment of a sample to a cluster when the sample's silhouette value is less than \code{silCutoff}}
 \item{"silCutoff"}{Cutoff on the minimum silhouette width to be included in
  cluster (only used if removeSil=TRUE).}
}
}
\examples{
data(simData)
cl1<-clusterD(x=simData,clusterFunction="pam",clusterArgs=list(k=3))
cl2<-clusterD(simData,clusterFunction="hierarchical01",clusterArgs=list(alpha=.1))
cl3<-clusterD(simData,clusterFunction="tight",clusterArgs=list(alpha=.1))
#change distance to manhattan distance
cl4<-clusterD(simData,clusterFunction="pam",clusterArgs=list(k=3),
     distFunction=function(x){dist(x,method="manhattan")})

#run hierarchical method for finding blocks, with method of evaluating
#coherence of block set to evalClusterMethod="average", and the hierarchical
#clustering using single linkage:
clustSubHier <- clusterD(simData, clusterFunction="hierarchical01",
minSize=5, clusterArgs=list(alpha=0.1,evalClusterMethod="average", method="single"))

#do tight
clustSubTight <- clusterD(simData, clusterFunction="tight", clusterArgs=list(alpha=0.1),
minSize=5)

#two twists to pam
clustSubPamK <- clusterD(simData, clusterFunction="pam", silCutoff=0, minSize=5,
removeSil=TRUE, clusterArgs=list(k=3))
clustSubPamBestK <- clusterD(simData, clusterFunction="pam", silCutoff=0,
minSize=5, removeSil=TRUE, findBestK=TRUE, kRange=2:10)

# note that passing the wrong arguments for an algorithm results in warnings
# (which can be turned off with checkArgs=FALSE)
clustSubTight_test <- clusterD(simData, clusterFunction="tight",
clusterArgs=list(alpha=0.1), minSize=5, removeSil=TRUE)
clustSubTight_test2 <- clusterD(simData, clusterFunction="tight",
clusterArgs=list(alpha=0.1,evalClusterMethod="average"))
}
