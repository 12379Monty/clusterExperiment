% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/compareChoices.R
\name{compareChoices}
\alias{compareChoices}
\title{Create a matrix of clustering across values of k}
\usage{
compareChoices(data, ks, clusterMethod, alphas = 0.1, findBestK = FALSE,
  sequential = FALSE, removeSil = FALSE, subsample = FALSE,
  silCutoff = 0, clusterDArgs = list(minSize = 5),
  subsampleArgs = list(resamp.num = 50), seqArgs = list(beta = 0.9, k.min =
  3, verbose = FALSE), ncores = 1, random.seed = NULL, run = TRUE,
  paramMatrix = NULL, ...)
}
\arguments{
\item{data}{the data on which to run the clustering. Must either be a data.frame/matrix (with samples in rows) or a list of datasets overwhich the clusterings should be run.}

\item{ks}{the range of k values (see details for meaning for different choices).}

\item{clusterMethod}{method used in clustering of subsampled data passed to argument 'cluserFunction' of \code{\link{clusterD}}. Note that unlike other functions of this package, this must be a character vector of pre-defined clustering techniques provided by the package, and can not be user-defined.}

\item{alphas}{values of alpha to be tried. Only used for subsampleClusterMethod either 'tight' or 'hierarchical'.}

\item{findBestK}{values of findBestK to be tried (logical) (only for 'pam').}

\item{sequential}{values of sequential to be tried (logical) (only for 'pam')}

\item{removeSil}{values of removeSil to be tried (logical) (only for 'pam')}

\item{subsample}{values of subsample to be tried (logical).}

\item{silCutoff}{values of silCutoff to be tried (only for 'pam')}

\item{clusterDArgs}{list of arguments to be passed to \code{\link{clusterD}}}

\item{subsampleArgs}{list of arguments to be passed to \code{\link{subsampleClustering}}}

\item{seqArgs}{list of arguments to be passed to \code{\link{seqCluster}}}

\item{ncores}{the number of threads}

\item{random.seed}{a value to set seed before each run of clusterAll (so that all of the runs are run on the same subsample of the data)}

\item{run}{logical. If FALSE, doesn't run clustering, but just returns matrix of parameters that will be run for inspection by user (with rownames equal to the names of the resulting column names of clMat object that would be returned if \code{run=TRUE}).}

\item{paramMatrix}{matrix or data.frame. If given, the algorithm will bypass creating the matrix of possible parameters, and will use the given matrix. There are basically no checks as to whether this matrix is in the right format, and is only intended to be used to feed the results of setting \code{run=FALSE} back into the algorithm (see example).}

\item{...}{arguments to be passed on to mclapply (if ncores>1)}
}
\value{
If \code{run=TRUE}, a list with the following objects:
\itemize{
\item{\code{clMat}}{a matrix of with each row corresponding to a clustering and each column a sample.}
\item{\code{clusterInfo}}{a list with information regarding clustering result (only relevant entries for those clusterings with sequential=TRUE)}
}

If \code{run=FALSE}, a matrix which each row corresponding to a set of parameters to pass to \code{\link{clusterAll}}. This matrix can be given to \code{paramMatrix} to then run these parameter choices.
}
\description{
Given a range of k's, this funciton will return a matrix with the clustering of the samples
across the range, which can be passed to \code{plotTracking} for visualization.
}
\details{
While the function allows for multiple values of clusterMethod, the code does not reuse the same subsampling matrix and try different clusterMethods on it. If sequential=TRUE, different subsampleClusterMethods will create different sets of data to subsample so it is not possible; if sequential=FALSE, we have not implemented functionality for this reuse. Setting the \code{random.seed} value, however, should mean that the subsampled matrix is the same for each, but there is no gain in computational complexity (i.e. each subsampled co-occurence matrix is recalculated for each set of parameters).
}
\examples{
data(simData)
#clustering using pam: try using different dimensions of pca and different k
ps<-c(5,10,50)
names(ps)<-paste("npc=",ps,sep="")
pcaData<-stats::prcomp(simData, center=TRUE, scale=TRUE)

#check how many and what runs user choices will imply:
#Note that this causes error:
\dontrun{
checkParams <- compareChoices(lapply(ps,function(p){pcaData$x[,1:p]}), clusterMethod="pam",
ks=2:4,findBestK=c(TRUE,FALSE),run=FALSE)
}
#fixes error, but really, not clear what best subsampling k should be
checkParams <- compareChoices(lapply(ps,function(p){pcaData$x[,1:p]}), clusterMethod="pam",
ks=2:4,findBestK=c(TRUE,FALSE),run=FALSE,subsampleArgs=list("k"=3))
#Now actually run it
cl <- compareChoices(lapply(ps,function(p){pcaData$x[,1:p]}), clusterMethod="pam",ks=2:4,findBestK=c(TRUE,FALSE),subsampleArgs=list("k"=3))
colnames(cl$clMat)
#make names shorter for plotting
colnames(cl$clMat)<-gsub("TRUE","T",colnames(cl$clMat))
colnames(cl$clMat)<-gsub("FALSE","F",colnames(cl$clMat))
colnames(cl$clMat)<-gsub("k=NA,","",colnames(cl$clMat))
par(mar=c(2,10,1,1))
plotTracking(cl$clMat,axisLine=-2)
#get rid of some of the choices manually
checkParams<-checkParams[-c(1,2),]
clSmaller<-compareChoices(lapply(ps,function(p){pcaData$x[,1:p]}),paramMatrix=checkParams)



\dontrun{
	#following code takes around 1+ minutes to run because of the subsampling that is redone each time:
	system.time(clusterTrack<-compareChoices(simData, ks=2:15,
	alphas=c(0.1,0.2,0.3), findBestK=c(TRUE,FALSE),sequential=c(FALSE),
	subsample=c(FALSE),removeSil=c(TRUE), clusterMethod="pam",
	clusterDArgs = list(minSize = 5,kRange=2:15),ncores=1,random.seed=48120))
}
}

