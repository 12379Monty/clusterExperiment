% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/dualHeatmap.R
\docType{methods}
\name{dualHeatmap}
\alias{dualHeatmap}
\title{Heatmap with two different sources for hierarchical clustering and color scale.}
\usage{
dualHeatmap(clusterVector, heatData, clusterData = heatData, eps = 1,
  dual = TRUE, clusterSamples = TRUE, clusterVar = TRUE,
  whVars = 1:nrow(heatData), varNames = FALSE, sampleNames = FALSE,
  colorScale = seqPal5, annCol = NULL, annColors = NULL,
  whAnnCont = NULL, alignColors = FALSE, breaks = NA,
  unassignedColor = "white", missingColor = "grey", ...)
}
\arguments{
\item{clusterVector}{A vector with cluster assignments to show at top of heatmap
with cells. ``-1'' indicates the sample was not assigned to a cluster and
gets color `white'.}

\item{heatData}{matrix to define the color scale (i.e. the counts). Will be
converted to log-scale internally. Assumes samples on rows and variables on
columns.}

\item{clusterData}{Either a matrix define the hiearchical clustering of
samples (e.g. normalized data) or a dendrogram for clustering the samples
(only used if dual=TRUE).}

\item{eps}{Amount to add to heatData so can take log}

\item{dual}{Logical as to whether should use clusterData for dendrogram;
otherwise heatData is used.}

\item{clusterSamples}{Logical as to whether to do hierarchical clustering of
cells.}

\item{clusterVar}{Logical as to whether to do hiearchical clustering of
genes.}

\item{whVars}{Which genes of heatData matrix to be used. Default assumes top 500,
which may be nonsensical if matrix not ordered.}

\item{varNames}{Logical as to whether show gene names}

\item{sampleNames}{Logical as to whether show cell names}

\item{colorScale}{palette of colors for the color scale of heatmap}

\item{annCol}{data.frame of clusters to show at the top of heatmap (columns
are clusters). If NULL, will show clusterVector. Can also be continuous valued data, but see details.}

\item{annColors}{Assignment of colors to the clusters. If NULL, clusters
will be assigned colors. If `annCol' should be list of length equal to
ncol(annCol) with names equal to the colnames of annCol; each element of the
list should be a vector of colors with names corresponding to the levels of
the column of annCol. If annCol=NULL (i.e. use clusterVec), then the name of
the length-1 list should be `Cluster'}

\item{whAnnCont}{which columns of annCol are continuous data; only relevant if annCol=NULL (i.e. function assigns the clusters)}

\item{alignColors}{Logical as to whether should align the clusters when
colors are assigned}

\item{breaks}{Either a vector of breaks (should be equal to length 52), or a
number between 0 and 1, indicating that the breaks should be equally spaced
(on the log scale+eps) upto the `breaks' quantile.}

\item{...}{passed to aheatmap}
}
\value{
Returns invisibly the breaks, annCol, and annColors that are sent to
aheatmap by the function.
}
\description{
Make heatmap with color scale from one matrix and hiearchical clustering
from another. Also color palettes to go with heatmap
}
\details{
Note that dualHeatmap calles aheatmap under the hood. This allows you to
plot multiple heatmaps via par(mfrow=c(2,2)), etc. However, the dendrograms
do not resize if you change the size of your plot window in an interactive
session of R (this might be a problem for RStudio if you want to pop it out
into a large window...).

The dualHeatmap function calles \code{\link{aheatmap}} to draw the heatmap. The main point of \code{dualHeatmap} is to 1) allow for two different matrix inputs, one to visualize and one to cluster.
2) to assign colors to the clusters like in \code{\link{plotTracking}} that lines them up based on their similarity
}
\examples{
data(simCount)
data(simData)
cl<-rep(1:3,each=100)
cl2<-cl
changeAssign<-sample(1:length(cl),80)
cl2[changeAssign]<-sample(cl[changeAssign])

#simple, minimal, example. Show counts, but cluster on underlying means
dualHeatmap(cl,heatData=simCount,clusterData=simData)

#assign cluster colors
colors<-bigPalette[20:23]
names(colors)<-1:3
dualHeatmap(cl,heatData=simCount,clusterData=simData,annColors=list(colors))

#show two different clusters
anno<-data.frame(cluster1=cl,cluster2=cl2)
out<-dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno)
#return the values to see format for giving colors to the annotations
out$annColors

#assign colors to the clusters based on plotTracking algorithm
dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno,
alignColors=TRUE)

#assign colors manually
annoColors<-list(cluster1=c("black","red","green"),
cluster2=c("blue","purple","yellow"))
dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno,
annColors=annoColors)

#give a continuous valued -- need to indicate columns
anno2<-cbind(anno,Cont=c(rnorm(100,0),rnorm(100,2),rnorm(100,3)))
dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno2,
whAnnCont=3)
#compare changing breaks quantile on visual effect
\dontrun{
par(mfrow=c(2,2))
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=1,main="Full length")
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=.99,main="0.99 Quantile Upper Limit")
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=.95,main="0.95 Quantile Upper Limit")
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=.90,main="0.90 Quantile Upper Limit")
}
}
\author{
Elizabeth Purdom
}

