% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dualHeatmap.R
\docType{methods}
\name{dualHeatmap}
\alias{dualHeatmap}
\title{Heatmap with two different sources for hierarchical clustering and color scale.}
\usage{
dualHeatmap(clusterVector, heatData, clusterData = heatData, eps = 1,
  dual = TRUE, clusterSamples = TRUE, clusterVars = TRUE,
  whVars = 1:nrow(heatData), varNames = FALSE, sampleNames = FALSE,
  colorScale = seqPal5, annCol = NULL, annColors = NULL,
  whAnnCont = NULL, alignColors = FALSE, breaks = NA,
  unassignedColor = "white", missingColor = "grey", ...)
}
\arguments{
\item{clusterVector}{A numeric vector with cluster assignments to show at top of heatmap
with cells. ``-1'' indicates the sample was not assigned to a cluster and
gets color `white'.}

\item{heatData}{matrix to define the color scale (i.e. the counts). Will be
converted to log-scale internally. Assumes samples on rows and variables on
columns.}

\item{clusterData}{Either a matrix define the hiearchical clustering of
samples (e.g. normalized data) or a dendrogram for clustering the samples
(only used if dual=TRUE).}

\item{eps}{Amount to add to heatData so can take log}

\item{dual}{Logical as to whether should use clusterData for dendrogram;
otherwise heatData is used.}

\item{clusterSamples}{Logical as to whether to do hierarchical clustering of
cells.}

\item{clusterVars}{Logical as to whether to do hiearchical clustering of
genes.}

\item{whVars}{Which genes of heatData matrix to be used. Default assumes top 500,
which may be nonsensical if matrix not ordered.}

\item{varNames}{Logical as to whether show gene names}

\item{sampleNames}{Logical as to whether show cell names}

\item{colorScale}{palette of colors for the color scale of heatmap}

\item{annCol}{data.frame of clusters to show at the top of heatmap (columns
are clusters). If NULL, will show clusterVector. Can also be continuous valued data, but see details.}

\item{annColors}{Assignment of colors to the clusters. If NULL, clusters
will be assigned colors. If `annCol' should be list of length equal to
ncol(annCol) with names equal to the colnames of annCol; each element of the
list should be a vector of colors with names corresponding to the levels of
the column of annCol. If annCol=NULL (i.e. use clusterVec), then the name of
the length-1 list should be `Cluster'}

\item{whAnnCont}{which columns of annCol are continuous data; only used if annCol=NULL (i.e. function \code{dualHeatmap} assigns the clusters' colors)}

\item{alignColors}{Logical as to whether should align the clusters when
colors are assigned (only used if annCol=NULL)}

\item{breaks}{Either a vector of breaks (should be equal to length 52), or a
number between 0 and 1, indicating that the breaks should be equally spaced
(on the log scale+eps) upto the `breaks' quantile, see details}

\item{unassignedColor}{color assigned to cluster values of '-1' ("unassigned")}

\item{missingColor}{color assigned to cluster values of '-2' ("missing")}

\item{...}{passed to aheatmap}
}
\value{
Returns (invisibly) a list with elements that are passed to aheatmap.
\itemize{
\item{\code{breaks}}{The breaks used for aheatmap, after adjusting for quantile}
\item{\code{annCol}}{the annotation data.frame given to aheatmap}
\item{\code{annColors}}{the annotation colors given to aheatmap}
}
}
\description{
Make heatmap with color scale from one matrix and hiearchical clustering
from another. Also color palettes to go with heatmap
}
\details{
Note that dualHeatmap calles aheatmap under the hood. This allows you to
plot multiple heatmaps via par(mfrow=c(2,2)), etc. However, the dendrograms
do not resize if you change the size of your plot window in an interactive
session of R (this might be a problem for RStudio if you want to pop it out
into a large window...).

The dualHeatmap function calles \code{\link{aheatmap}} to draw the heatmap. The main point of \code{dualHeatmap} is to 1) allow for two different matrix inputs, one to visualize and one to cluster. 
2) to assign colors to the clusters like in \code{\link{plotTracking}} that lines them up based on their similarity. 
The intended purpose is to allow the user to visualize the original count scale of the data (on the log-scale), but create the hierarchical clustering on another, more appropriate dataset for clustering, such as normalized data. Similarly, some of the palettes were developed assuming that the visualization might be on unscaled/uncentered data, rather than the residual from the mean of the gene, and thus palettes need to take on a greater range of relevant values so as to show meaningful comparisons with genes on very different scales.  


If \code{annCol} contains a column of continuous data, whAnnCont should give the index of the column(s); otherwise the annotation data for those columns will be forced into a non-sensical factor (with nlevels equal the the number of samples). 


If breaks is a numeric value between 0 and 1, then \code{breaks} is assumed to indicate the upper quantile (on the log scale) at which the heatmap color scale should stop. For example, if breaks=0.9, then the breaks will evenly spaced up until the 0.9 upper quantile of the log of the \code{heatData}, and then all values after the 0.9 quantile will be absorbed by the upper-most color bin. This can help to reduce the visual impact of a few highly expressed genes (variables).
}
\examples{

data(simData)
data(simData)
cl<-rep(1:3,each=100)
cl2<-cl
changeAssign<-sample(1:length(cl),80)
cl2[changeAssign]<-sample(cl[changeAssign])

#simple, minimal, example. Show counts, but cluster on underlying means
dualHeatmap(cl,heatData=simCount,clusterData=simData)

#assign cluster colors
colors<-bigPalette[20:23]
names(colors)<-1:3
dualHeatmap(cl,heatData=simCount,clusterData=simData,annColors=list(colors))

#show two different clusters
anno<-data.frame(cluster1=cl,cluster2=cl2)
out<-dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno)
#return the values to see format for giving colors to the annotations
out$annColors

#assign colors to the clusters based on plotTracking algorithm
dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno,
alignColors=TRUE)

#assign colors manually
annoColors<-list(cluster1=c("black","red","green"),
cluster2=c("blue","purple","yellow"))
dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno,
annColors=annoColors)

#give a continuous valued -- need to indicate columns
anno2<-cbind(anno,Cont=c(rnorm(100,0),rnorm(100,2),rnorm(100,3)))
dualHeatmap(cl,heatData=simCount,clusterData=simData,annCol=anno2,
whAnnCont=3)
#compare changing breaks quantile on visual effect
\dontrun{
par(mfrow=c(2,2))
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=1,main="Full length")
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=.99,main="0.99 Quantile Upper Limit")
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=.95,main="0.95 Quantile Upper Limit")
dualHeatmap(cl,heatData=simCount,clusterData=simData,colorScale=seqPal1,
breaks=.90,main="0.90 Quantile Upper Limit")
}


}
\author{
Elizabeth Purdom
}

