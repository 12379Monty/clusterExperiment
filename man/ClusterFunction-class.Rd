% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllClasses.R
\docType{class}
\name{ClusterFunction-class}
\alias{ClusterFunction-class}
\alias{ClusterFunction}
\alias{clusterFunction}
\alias{internalFunctionCheck}
\alias{clusterFunction}
\alias{clusterFunction,function-method}
\title{Class ClusterFunction}
\usage{
internalFunctionCheck(FUN, inputType, algType, outputType)

clusterFunction(clusterFUN, ...)

\S4method{clusterFunction}{`function`}(clusterFUN, inputType, outputType,
  algorithmType, inputClassifyType = NA_character_,
  requiredArgs = NA_character_, classifyFUN = NULL, checkFunctions = TRUE)
}
\arguments{
\item{inputType}{character}

\item{clusterFUN}{a function that clusters data}

\item{algorithmType}{character}

\item{classifyFUN}{function that classifies new data based on cluster results of FUN}
}
\value{
A \code{ClusterFunction} object.
}
\description{
\code{ClusterFunction} is a class ...

The constructor \code{clusterFunction} creates an object of
the class \code{ClusterFunction}.
}
\details{
Required arguments for \code{clusterFUN}:
\itemize{
 \item{"x or diss"}{either \code{x} and/or \code{diss} depending on \code{inputType}. If \code{x}, then \code{x} is assumed to be nfeatures x nsamples (like assay(CEObj) would give)}
 \item{"checkArgs"}{logical argument. If \code{checkArgs=TRUE}, the \code{clusterFUN} should check if the arguments passed in \code{...} are valid and return an error if not; otherwise, no error will be given, but the check should be done and only valid arguments in \code{...} passed along. This is necessary for the function to work with \code{clusterMany} which passes all arguments to all functions without checking. }
\item{"cluster.only"}{logical argument. If \code{cluster.only=TRUE}, then \code{clusterFUN} should return only the vector of cluster assignments; the vector should be in the same order as the original input of the data, with integers identifying them to different clusters; samples that are not assigned to any cluster should be given a '-1' value. If \code{cluster.only=FALSE} then the \code{clusterFUN} should return a named list where one of the elements entitled \code{clustering} contains the vector described above; anything needed by the \code{classifyFUN} to classify new data should be contained in the list as well. \code{cluster.only} is set internally depending on whether \code{classifyFUN} will be used by subsampling or only for clustering the final product.}
\item{"..."}{Any additional arguments specific to the algorithm used by \code{clusterFUN} should be passed via \code{...} and NOT passed via arguments to \code{clusterFUN}}
\item{"Other required arguments"}{\code{clusterFUN} must also accept arguments required for its \code{algorithmType} (see Details below).}
}

The \code{clusterFunction} must be a function that takes as an
  argument 'x' which is a \code{p x n} matrix  of data and integer 'k'. It
  minimally must return a list with element named 'clustering' giving the
  vector of cluster ids. To be incorporated with the larger hierarchy, it
  should be list with elements of a partition object, just as is returned by
  \code{\link[cluster]{pam}}. Generally, the user will need to write a
  wrapper function to do this. In the case of pam or kmeans, the user can
  identify clusterFunction as "pam" or "kmeans", and the package functions
  will use internally written wrappers for the clusterFunction and
  classifyFunction arguments. Additional arguments should be supplied via
  clusterArgs.

The classifyFunction should take as an object a data matrix 'x' with
  samples on the columns, and the output of the clusterFunction. Note that the
  function should assume that the input 'x' is not the same samples that were
  input to the clusterFunction (but can assume that it is the same number of
  features/columns).

\code{algorithmType}: "01" is for clustering functions that
  expect as an input a dissimilarity matrix D that takes on 0-1 values (e.g. from subclustering). "01" types must have \code{inputType} equal to \code{"diss"}
  "K" is for clustering functions that require an argument \code{k} (the number of
  clusters), but arbitrary \code{inputType}. It is also generally expected
  that "01" algorithms use the 0-1 nature of the input to set criteria
  as to where to find clusters and therefore do not need a pre-determined
  'k'. On the other hand, "K" algorithms are assumed to need a
  predetermined 'k' and are also assumed to cluster all samples to a cluster,
  and therefore clusterK gives options to exclude poorly clustered samples
  via silhouette distances.

cluster01 required format for input and output for clusterFunction:
  clusterFunction should be a function that takes (as a minimum) an argument
  "diss" (D) and "alpha". 0-1 clustering algorithms are expected to use the fact
  that the D input is 0-1 range to find the clusters, rather than a user
  defined number of clusters; "alpha" is the parameter that tunes the finding
  of such clusters. For example, a candidate block of samples might be
  considered a cluster if all values of D are greater than or equal to
  1-alpha. The output is a list with each element corresponding to a cluster
  and the elements of the list corresponding to the indices of the samples
  that are in the cluster. The list is expected to be in order of 'best
  clusters' (as defined by the clusterFunction), with first being the best
  and last being worst.

Available "01" methods: "tight" method refers to the method of finding 
    clusters from a subsampling matrix given internally in the tight 
    algorithm code of Tsang and Wong. Arguments for the tight method are
    'minSize.core' (default=2), which sets the minimimum number of samples
    that form a core cluster. "hierarchical01" refers to running the hclust
    algorithm on D and transversing down the tree until getting a block of
    samples with whose summary of the values  is greater than or equal to
    1-alpha. Arguments that can be passed to 'hierarchical' are
    'evalClusterMethod' which determines how to summarize the samples' values
    of D[samples,samples] for comparison to 1-alpha: "maximum" (default)
    takes the minimum of D[samples,samples] and requires it to be less than
    or equal to 1-alpha; "average" requires that each row mean of
    D[samples,samples] be less than or equal to 1-alpha. Arguments of
    hclust can also be passed via clusterArgs to control the hierarchical 
    clustering of D.

"K" algorithms required format for input and output for clusterFunction:
  clusterFunction should be a function that takes as a minimum an argument
  'k', in addition to input \code{x} or \code{diss} depending on \code{inputType}.

clusterK methods: "pam" performs pam clustering on the input 
  \code{D} matrix using \code{\link{pam}} in the cluster package. Arguments 
  to \code{\link{pam}} can be passed via 'clusterArgs', except for the 
  arguments 'x' and 'k' which are given by D and k directly. "hierarchicalK"
  performs hierarchical clustering on the input via the \code{\link{hclust}}
  and then applies \code{\link{cutree}} with the specified k to obtain
  clusters. Arguments to \code{\link{hclust}} can be passed via
  \code{clusterArgs}.
}
\section{Slots}{

\describe{
\item{\code{clusterFUN}}{a function defining the clustering function. See details for required arguments.}

\item{\code{inputType}}{a character defining what type of input \code{clusterFUN} takes. Must be one of either "D","X", or "Either"}

\item{\code{algorithmType}}{a character defining what type of clustering algorithm \code{clusterFUN} is. Must be one of either "01" or "K". \code{clusterFUN} must take the corresponding required arguments.}

\item{\code{classifyFUN}}{a function that takes as input new data and the output of \code{clusterFUN} and results in cluster assignments of the new data. Used in subsampling clustering. If \code{NULL} then subsampling can only be \code{"InSample"}, see \code{\link{subsampleClustering}}.}
}}

\examples{
goodFUN<-function(x,diss,k,checkArgs,cluster.only,...){pam(x=t(x),k=k)}
internalFunctionCheck(goodFUN,inputType="either",algType="K",outputType="vector")
badFUN<-function(x,diss,k,checkArgs,cluster.only,...){pam(x=x,k=k)}
internalFunctionCheck(badFUN,inputType="either",algType="K",outputType="vector")
}
